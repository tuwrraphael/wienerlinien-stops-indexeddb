{"version":3,"file":"index.js","sources":["../src/bounding-coordinates.ts","../src/index.ts","../src/process-stream.ts","../src/split-csv-line.ts"],"sourcesContent":["const MAX_LAT = Math.PI / 2; // 90 degrees\r\nconst MIN_LAT = -MAX_LAT; // -90 degrees\r\nconst MAX_LON = Math.PI; // 180 degrees\r\nconst MIN_LON = -MAX_LON; // -180 degrees\r\nconst FULL_CIRCLE_RAD = Math.PI * 2; // Full cirle (360 degrees) in radians\r\n\r\nconst toRad = x => x * (Math.PI / 180);\r\nconst toDeg = x => x / (Math.PI / 180);\r\n\r\nexport function boundingCoordinates(lat, lon, distance) {\r\n    lat = toRad(lat);\r\n    lon = toRad(lon);\r\n    let radDist = distance / 6371.01,\r\n        minLat = lat - radDist,\r\n        maxLat = lat + radDist,\r\n        minLon,\r\n        maxLon,\r\n        deltaLon;\r\n    if (minLat > MIN_LAT && maxLat < MAX_LAT) {\r\n        deltaLon = Math.asin(Math.sin(radDist) / Math.cos(lat));\r\n        minLon = lon - deltaLon;\r\n        if (minLon < MIN_LON) {\r\n            minLon += FULL_CIRCLE_RAD;\r\n        }\r\n        maxLon = lon + deltaLon;\r\n        if (maxLon > MAX_LON) {\r\n            maxLon -= FULL_CIRCLE_RAD;\r\n        }\r\n    } else {\r\n        minLat = Math.max(minLat, MIN_LAT);\r\n        maxLat = Math.min(maxLat, MAX_LAT);\r\n        minLon = MIN_LON;\r\n        maxLon = MAX_LON;\r\n    }\r\n    return [toDeg(minLat), toDeg(minLon), toDeg(maxLat), toDeg(maxLon)];\r\n};","import { processStream } from \"./process-stream\";\r\nimport { boundingCoordinates } from \"./bounding-coordinates\";\r\n\r\nconst STATION_URL = \"https://www.data.wien.gv.at/txt/wrlinien-gtfs-stops.txt\";\r\nconst WEEK = 7 * 24 * 60 * 60 * 1000;\r\n\r\nexport class StopStore {\r\n\r\n    constructor(private dbName: string) {\r\n    }\r\n\r\n    async import(saveStops) {\r\n        let res = await fetch(STATION_URL);\r\n        const bodyAsTextStream = res.body.pipeThrough(new TextDecoderStream());\r\n        await processStream(bodyAsTextStream, saveStops);\r\n    }\r\n\r\n    query(lat, lng, r) {\r\n        const [minLat, minLon, maxLat, maxLon] = boundingCoordinates(lat, lng, r / 1000);\r\n        return new Promise((resolve, reject) => {\r\n            let lat_range = IDBKeyRange.bound(minLat, maxLat);\r\n            let long_range = IDBKeyRange.bound(minLon, maxLon);\r\n            this.openDb().then(db => {\r\n                let tx = db.transaction(\"Stops\");\r\n                let obj_store = tx.objectStore(\"Stops\");\r\n                let res = [];\r\n                let results = [];\r\n                let lat_request = obj_store.index('stop_lat').getAllKeys(lat_range);\r\n                let lng_request = obj_store.index('stop_lon').getAllKeys(long_range);\r\n                function provideResults() {\r\n                    let tx = db.transaction(\"Stops\");\r\n                    let obj_store = tx.objectStore(\"Stops\");\r\n                    let objs = [];\r\n                    results.forEach(v => {\r\n                        let request = obj_store.get(v);\r\n                        request.onsuccess = () => {\r\n                            objs.push(request.result);\r\n                            if (objs.length == results.length) {\r\n                                resolve(objs);\r\n                            }\r\n                        };\r\n                        request.onerror = err => reject(err);\r\n                    });\r\n                }\r\n                lat_request.onsuccess = () => {\r\n                    if (res.length) {\r\n                        results = lat_request.result.filter(s => res.indexOf(s) > -1);\r\n                        provideResults();\r\n                    }\r\n                    res = lat_request.result;\r\n                }\r\n                lat_request.onerror = err => reject(err);\r\n                lng_request.onsuccess = () => {\r\n                    if (res.length) {\r\n                        results = lng_request.result.filter(s => res.indexOf(s) > -1);\r\n                        provideResults();\r\n                    }\r\n                    res = lng_request.result;\r\n                }\r\n                lng_request.onerror = err => reject(err);\r\n            }, err => reject(err));\r\n        });\r\n    }\r\n\r\n\r\n    openDb(): Promise<IDBDatabase> {\r\n        let self = this;\r\n        return new Promise((resolve, reject) => {\r\n            let request = window.indexedDB.open(self.dbName, 2);\r\n            request.onsuccess = function () {\r\n                resolve(request.result);\r\n            }\r\n            request.onupgradeneeded = function (ev) {\r\n                if (ev.oldVersion < 2) {\r\n                    let stopStore = request.result.createObjectStore(\"Stops\", { keyPath: \"stop_id\" });\r\n                    stopStore.createIndex(\"stop_lat\", \"stop_lat\", { unique: false });\r\n                    stopStore.createIndex(\"stop_lon\", \"stop_lon\", { unique: false });\r\n                    stopStore.createIndex('version', ['version'], { unique: false });\r\n                    request.result.createObjectStore(\"Logs\", { keyPath: \"id\" });\r\n                }\r\n            }\r\n            request.onerror = function (err) {\r\n                reject(err);\r\n            }\r\n        });\r\n    }\r\n\r\n    getLogEntry(): Promise<{ version: number, updated: number }> {\r\n        return new Promise((resolve, reject) => {\r\n            this.openDb().then(db => {\r\n                let tx = db.transaction(\"Logs\");\r\n                let logsStore = tx.objectStore(\"Logs\");\r\n                let request = logsStore.get(0);\r\n                request.onsuccess = () => resolve(<{ version: number, updated: number }>request.result || { version: 0, updated: 0 });\r\n                request.onerror = err => reject(err);\r\n            }, err => reject(err));\r\n        });\r\n    }\r\n\r\n    async maintainDb() {\r\n        let db = await this.openDb();\r\n        let logEntry = await this.getLogEntry();\r\n        if (+new Date() - logEntry.updated < WEEK) {\r\n            return;\r\n        }\r\n        logEntry.version++;\r\n        await this.import(function (stops) {\r\n            let tx = db.transaction(\"Stops\", \"readwrite\");\r\n            let stopStore = tx.objectStore(\"Stops\");\r\n            for (let stop of stops) {\r\n                stopStore.put({ ...stop, version: logEntry.version });\r\n            }\r\n        });\r\n        let tx = db.transaction(\"Stops\", \"readwrite\");\r\n        let stopStore = tx.objectStore(\"Stops\");\r\n        var pdestroy = stopStore.index(\"version\").openKeyCursor(IDBKeyRange.only(logEntry.version - 1));\r\n        pdestroy.onsuccess = function () {\r\n            var cursor = pdestroy.result;\r\n            if (cursor) {\r\n                stopStore.delete(cursor.primaryKey);\r\n                cursor.continue;\r\n            }\r\n        }\r\n        tx = db.transaction(\"Logs\", \"readwrite\");\r\n        let logStore = tx.objectStore(\"Logs\");\r\n        logStore.put({ id: 0, updated: +new Date(), version: logEntry.version });\r\n    }\r\n}","import { splitCsvLine } from \"./split-csv-line\";\r\n\r\nexport function processStream(bodyAsTextStream: ReadableStream, saveStops) {\r\n    return new Promise((resolve, reject) => {\r\n        let accumulate = \"\";\r\n        let header = false;\r\n        let map = { stop_id: 0, stop_name: 0, stop_lat: 0, stop_lon: 0 };\r\n        let numProps = Object.keys(map).length;\r\n        const appendStream = new WritableStream({\r\n            write(chunk) {\r\n                let stops = [];\r\n                accumulate += chunk;\r\n                let incomplete = false;\r\n                let splitted = accumulate.replace(/\\r/g, \"\").split(\"\\n\");\r\n                splitted.map(stopString => {\r\n                    let stopSplitted = Array.from(splitCsvLine(stopString, \",\"));\r\n                    if (!header || accumulate.length < 2) {\r\n                        for (let prop in map) {\r\n                            if (map.hasOwnProperty(prop)) {\r\n                                map[prop] = stopSplitted.indexOf(prop);\r\n                            }\r\n                        }\r\n                        header = true;\r\n                    }\r\n                    if (header && stopSplitted.length >= numProps) {\r\n                        stops.push({\r\n                            stop_id: stopSplitted[map.stop_id],\r\n                            stop_name: stopSplitted[map.stop_name],\r\n                            stop_lat: parseFloat(stopSplitted[map.stop_lat]),\r\n                            stop_lon: parseFloat(stopSplitted[map.stop_lon])\r\n                        });\r\n                    } else {\r\n                        incomplete = true;\r\n                    }\r\n                });\r\n                if (incomplete) {\r\n                    accumulate = splitted[splitted.length - 1];\r\n                }\r\n                else {\r\n                    accumulate = \"\";\r\n                }\r\n                if (stops.length) {\r\n                    saveStops(stops);\r\n                }\r\n            },\r\n            close: function () {\r\n                resolve();\r\n            },\r\n            abort: function () {\r\n                reject();\r\n            }\r\n        });\r\n        bodyAsTextStream.pipeTo(appendStream);\r\n    });\r\n}","export function* splitCsvLine(str, symbol) {\r\n    let splitted = str.split(symbol);\r\n    let accumulate = \"\";\r\n    for (let s of splitted) {\r\n        s = accumulate + s;\r\n        if (s[0] == \"\\\"\") {\r\n            if (s[s.length - 1] == \"\\\"\" && (s.length <= 2 || s[s.length - 2] != \"\\\"\")) {\r\n                yield s.substring(1, s.length - 1);\r\n                accumulate = \"\";\r\n            }\r\n            else {\r\n                accumulate += s;\r\n            }\r\n        } else {\r\n            yield s;\r\n            accumulate = \"\";\r\n        }\r\n    }\r\n    if (accumulate.length) {\r\n        yield accumulate;\r\n    }\r\n}"],"names":["MAX_LAT","Math","PI","MIN_LAT","MAX_LON","MIN_LON","FULL_CIRCLE_RAD","toRad","x","toDeg","STATION_URL","WEEK","StopStore","[object Object]","dbName","this","saveStops","bodyAsTextStream","fetch","body","pipeThrough","TextDecoderStream","Promise","resolve","reject","accumulate","header","map","stop_id","stop_name","stop_lat","stop_lon","numProps","Object","keys","length","appendStream","WritableStream","chunk","stops","incomplete","splitted","replace","split","stopString","stopSplitted","Array","from","str","symbol","s","substring","splitCsvLine","prop","hasOwnProperty","indexOf","push","parseFloat","close","abort","pipeTo","processStream","lat","lng","r","minLat","minLon","maxLat","maxLon","lon","distance","deltaLon","radDist","asin","sin","cos","max","min","boundingCoordinates","lat_range","IDBKeyRange","bound","long_range","openDb","then","db","obj_store","transaction","objectStore","res","results","lat_request","index","getAllKeys","lng_request","provideResults","objs","forEach","v","request","get","onsuccess","result","onerror","err","filter","self","window","indexedDB","open","onupgradeneeded","ev","oldVersion","stopStore","createObjectStore","keyPath","createIndex","unique","version","updated","logEntry","getLogEntry","Date","import","stop","put","tx","pdestroy","openKeyCursor","only","cursor","delete","primaryKey","continue","id"],"mappings":"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"}